using System.Text.RegularExpressions;
using CommandLine;

namespace WinGitFS;

internal enum GitProvider { AzureDevOps, GitHub }

internal sealed class GitFsOptions
{
    [Value(0, MetaName = "url", Required = true, HelpText = "Git repository URL (Azure DevOps or GitHub). Optionally include path/branch info:\n  ADO: https://dev.azure.com/org/Project/_git/Repo?path=/Apps/MyApp&version=GBmain\n    Query strings: path=<folder> (folder path), version=GB<branch> (Git branch)\n  GitHub: https://github.com/owner/repo/tree/branch/path")]
    public string Url { get; set; } = "";

    [Option("local-path", Required = false, HelpText = "Local folder path for virtualization root (will be created if needed). If not specified, creates a temp folder and opens it in Explorer")]
    public string? LocalPath { get; set; }

    [Option("pat", Required = false, HelpText = "Personal Access Token for authentication")]
    public string? Pat { get; set; }

    [Option("sso", Required = false, Default = false, HelpText = "Use Azure AD SSO authentication (Azure DevOps only)")]
    public bool Sso { get; set; }

    [Option("branch", Required = false, Default = "", HelpText = "Branch to map (defaults to repository's default branch)")]
    public string Branch { get; set; } = "";

    [Option("dirCacheTtlSeconds", Required = false, Default = 30, HelpText = "Directory cache TTL in seconds")]
    public int DirCacheTtlSeconds { get; set; } = 30;

    [Option("fileCacheSizeMb", Required = false, Default = 256, HelpText = "File content cache size cap in MB")]
    public int FileCacheSizeMb { get; set; } = 256;

    // Parsed/derived properties
    public GitProvider Provider { get; private set; }
    public string VirtualizationRoot { get; private set; } = "";
    public bool AutoGeneratedLocalPath { get; private set; }

    // Azure DevOps specific
    public Uri OrganizationUrl { get; private set; } = null!;
    public string Project { get; private set; } = "";

    // GitHub specific
    public string Owner { get; private set; } = "";

    // Common
    public string Repository { get; private set; } = "";
    public string? PersonalAccessToken { get; private set; }
    public bool UseSso => Sso;
    public string DefaultBranch => Branch;
    public string RemotePath { get; private set; } = "";  // Normalized: no leading/trailing slashes, forward slashes
    public TimeSpan DirectoryCacheTtl => TimeSpan.FromSeconds(Math.Clamp(DirCacheTtlSeconds, 1, 3600));
    public long FileCacheSizeBytes => Math.Max(16L * 1024 * 1024, (long)FileCacheSizeMb * 1024 * 1024);

    // Regex to parse ADO Git URLs:
    //   https://<org>.visualstudio.com/<project>/_git/<repo>[?path=/folder]
    //   https://<org>.visualstudio.com/_git/<repo>[?path=/folder]  (project = repo)
    //   https://dev.azure.com/<org>/<project>/_git/<repo>[?path=/folder]
    //   https://dev.azure.com/<org>/_git/<repo>[?path=/folder]  (project = repo)
    private static readonly Regex AdoUrlRegex = new(
        @"^https://(?:(?<org>[^./]+)\.visualstudio\.com|dev\.azure\.com/(?<org>[^/]+))(?:/(?<project>[^/]+))?/_git/(?<repo>[^/?]+)/?(?:\?.*)?$",
        RegexOptions.IgnoreCase | RegexOptions.Compiled);

    // Regex to parse GitHub URLs:
    //   https://github.com/<owner>/<repo>
    //   https://github.com/<owner>/<repo>/tree/<branch>
    //   https://github.com/<owner>/<repo>/tree/<branch>/<path>
    //   https://github.com/<owner>/<repo>/blob/<branch>/<path>
    private static readonly Regex GitHubUrlRegex = new(
        @"^https://github\.com/(?<owner>[^/]+)/(?<repo>[^/?#]+)(?:/(?:tree|blob)/(?<branch>[^/]+)(?<path>/.*)?)?",
        RegexOptions.IgnoreCase | RegexOptions.Compiled);

    /// <summary>Validates and processes the parsed options. Call after parsing.</summary>
    public void Validate()
    {
        var url = Url.Trim();

        // Try Azure DevOps first
        var adoMatch = AdoUrlRegex.Match(url);
        if (adoMatch.Success)
        {
            ValidateAzureDevOps(adoMatch, url);
            return;
        }

        // Try GitHub
        var gitHubMatch = GitHubUrlRegex.Match(url);
        if (gitHubMatch.Success)
        {
            ValidateGitHub(gitHubMatch, url);
            return;
        }

        throw new ArgumentException(
            "Invalid URL. Supported formats:\n" +
            "  Azure DevOps:\n" +
            "    https://<org>.visualstudio.com/<project>/_git/<repo>\n" +
            "    https://<org>.visualstudio.com/_git/<repo>\n" +
            "    https://dev.azure.com/<org>/<project>/_git/<repo>\n" +
            "    https://dev.azure.com/<org>/_git/<repo>\n" +
            "  GitHub:\n" +
            "    https://github.com/<owner>/<repo>\n" +
            "    https://github.com/<owner>/<repo>/tree/<branch>/<path>");
    }

    private void ValidateAzureDevOps(Match match, string url)
    {
        Provider = GitProvider.AzureDevOps;

        var org = match.Groups["org"].Value;
        Repository = match.Groups["repo"].Value;
        // If project is not specified in URL, it defaults to the repository name
        Project = match.Groups["project"].Success && !string.IsNullOrEmpty(match.Groups["project"].Value)
            ? match.Groups["project"].Value
            : Repository;

        // Determine org URL format
        if (url.Contains(".visualstudio.com", StringComparison.OrdinalIgnoreCase))
            OrganizationUrl = new Uri($"https://{org}.visualstudio.com");
        else
            OrganizationUrl = new Uri($"https://dev.azure.com/{org}");

        SetupLocalPath();
        SetupAuthentication("WINGITFS_ADO_PAT");

        // Extract optional path and version from URL query string
        // ?path=/folder/subfolder&version=GB<branchname>
        RemotePath = "";
        if (Uri.TryCreate(url, UriKind.Absolute, out var uri) && !string.IsNullOrEmpty(uri.Query))
        {
            var query = System.Web.HttpUtility.ParseQueryString(uri.Query);

            // Extract path parameter
            var pathParam = query["path"];
            if (!string.IsNullOrEmpty(pathParam))
            {
                RemotePath = pathParam.Replace('\\', '/').Trim('/').Trim();
            }

            // Extract version parameter (GB = Git Branch, GC = Git Commit, GT = Git Tag)
            // Only use if --branch wasn't explicitly set
            var versionParam = query["version"];
            if (!string.IsNullOrEmpty(versionParam) && string.IsNullOrEmpty(Branch))
            {
                if (versionParam.StartsWith("GB", StringComparison.OrdinalIgnoreCase))
                {
                    Branch = versionParam[2..];
                }
            }
        }
    }

    private void ValidateGitHub(Match match, string url)
    {
        Provider = GitProvider.GitHub;

        Owner = match.Groups["owner"].Value;
        Repository = match.Groups["repo"].Value;

        // Remove .git suffix if present
        if (Repository.EndsWith(".git", StringComparison.OrdinalIgnoreCase))
            Repository = Repository[..^4];

        SetupLocalPath();
        SetupAuthentication("WINGITFS_GITHUB_PAT");

        // Extract branch and path from URL if present
        // https://github.com/owner/repo/tree/branch/path/to/folder
        if (match.Groups["branch"].Success && !string.IsNullOrEmpty(match.Groups["branch"].Value))
        {
            // Only use URL branch if --branch wasn't explicitly set
            if (string.IsNullOrEmpty(Branch))
            {
                Branch = match.Groups["branch"].Value;
            }
        }

        if (match.Groups["path"].Success && !string.IsNullOrEmpty(match.Groups["path"].Value))
        {
            RemotePath = match.Groups["path"].Value.Replace('\\', '/').Trim('/').Trim();
        }
    }

    private void SetupLocalPath()
    {
        if (string.IsNullOrWhiteSpace(LocalPath))
        {
            var tempFolder = Path.Combine(Path.GetTempPath(), $"WinGitFS_{Repository}_{Guid.NewGuid():N}");
            VirtualizationRoot = tempFolder;
            AutoGeneratedLocalPath = true;
        }
        else
        {
            VirtualizationRoot = Path.GetFullPath(LocalPath.Trim());
            AutoGeneratedLocalPath = false;
        }
    }

    private void SetupAuthentication(string envVarName)
    {
        if (Sso)
        {
            if (Provider == GitProvider.GitHub)
            {
                throw new ArgumentException(
                    "GitHub does not support --sso. Please use --pat with a Personal Access Token.\n" +
                    "Create a PAT at: https://github.com/settings/tokens");
            }

            // Explicit SSO requested - don't use PAT even if available
            PersonalAccessToken = null;
        }
        else if (!string.IsNullOrWhiteSpace(Pat))
        {
            // Explicit PAT provided via argument
            PersonalAccessToken = Pat;
        }
        else
        {
            // Neither --sso nor --pat specified - fall back to env var
            PersonalAccessToken = Environment.GetEnvironmentVariable(envVarName);
            if (string.IsNullOrWhiteSpace(PersonalAccessToken))
            {
                throw new ArgumentException(
                    Provider == GitProvider.AzureDevOps
                        ? $"Authentication required. Use --sso for browser login, --pat <token>, or set env var {envVarName}"
                        : $"Authentication required. Use --pat <token> or set env var {envVarName}\n" +
                          "Create a GitHub PAT at: https://github.com/settings/tokens");
            }
        }
    }
}
