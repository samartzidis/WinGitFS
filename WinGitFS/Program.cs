using System.Diagnostics;
using System.Runtime.InteropServices;
using CommandLine;
using WinGitFS;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;

using var loggerFactory = LoggerFactory.Create(builder =>
{
    builder
        .AddSimpleConsole(o =>
        {
            o.SingleLine = true;
            o.TimestampFormat = "HH:mm:ss ";
        })
        .SetMinimumLevel(LogLevel.Debug);
});

var logger = loggerFactory.CreateLogger("WinGitFS");

return await Parser.Default.ParseArguments<GitFsOptions>(args)
    .MapResult(
        async options => await RunAsync(options),
        errors => Task.FromResult(1));

async Task<int> RunAsync(GitFsOptions options)
{
    string? virtualizationRootToCleanup = null;
    var createdVirtualizationRoot = false;
    IGitClient? gitClient = null;

    try
    {
        // Validate and process parsed options
        options.Validate();

        if (!Environment.Is64BitProcess)
        {
            logger.LogError("WinGitFS must run as a 64-bit process.");
            return 2;
        }

        virtualizationRootToCleanup = options.VirtualizationRoot;

        // Create virtualization root if it doesn't exist
        if (!Directory.Exists(options.VirtualizationRoot))
        {
            Directory.CreateDirectory(options.VirtualizationRoot);
            createdVirtualizationRoot = true;
            logger.LogInformation("Created virtualization root: {Root}", options.VirtualizationRoot);
        }
        else
        {
            logger.LogInformation("Using existing virtualization root: {Root}", options.VirtualizationRoot);
        }

        // Create appropriate Git client based on provider
        gitClient = await CreateGitClientAsync(options);

        // Validate credentials and repository access early
        logger.LogInformation("Validating access...");
        await gitClient.ValidateAsync();

        // Fetch default branch if not specified
        if (string.IsNullOrEmpty(options.Branch))
        {
            options.Branch = await gitClient.GetDefaultBranchAsync();
        }
        logger.LogInformation("Using branch: {Branch}", options.Branch);

        using var memoryCache = new MemoryCache(new MemoryCacheOptions
        {
            SizeLimit = options.FileCacheSizeBytes,
        });

        using var provider = new GitFsProvider(
            options,
            gitClient,
            memoryCache,
            loggerFactory.CreateLogger<GitFsProvider>());

        // Pin the provider to prevent GC collection - ProjFS native callbacks require
        // the managed delegate pointers to stay valid for the lifetime of the virtualization.
        var providerHandle = GCHandle.Alloc(provider);

        // Handle Ctrl+C gracefully
        using var cts = new CancellationTokenSource();
        Console.CancelKeyPress += (_, e) =>
        {
            e.Cancel = true; // Prevent immediate termination
            cts.Cancel();
        };

        try
        {
            provider.Start(new Meziantou.Framework.Win32.ProjectedFileSystem.ProjectedFileSystemStartOptions
            {
                UseNegativePathCache = true,
            });

            logger.LogInformation("WinGitFS running at {Root}", options.VirtualizationRoot);
            LogRepositoryInfo(options);
            logger.LogInformation("Press Enter or Ctrl+C to stop.");

            // Open Explorer if path was auto-generated
            if (options.AutoGeneratedLocalPath)
            {
                Process.Start("explorer.exe", options.VirtualizationRoot);
            }

            // Wait for Enter key or Ctrl+C
            try
            {
                while (!cts.Token.IsCancellationRequested && Console.KeyAvailable == false)
                {
                    await Task.Delay(100, cts.Token);
                }
                if (Console.KeyAvailable)
                    Console.ReadKey(intercept: true);
            }
            catch (OperationCanceledException) { }

            provider.Stop();
        }
        finally
        {
            providerHandle.Free();
        }

        return 0;
    }
    catch (ArgumentException ex)
    {
        logger.LogError(ex, "Invalid arguments.");
        return 2;
    }
    catch (Exception ex)
    {
        logger.LogError(ex, "Fatal error.");
        return 1;
    }
    finally
    {
        gitClient?.Dispose();

        // Clean up the virtualization root directory on exit (only if we created it)
        if (createdVirtualizationRoot && virtualizationRootToCleanup is not null && Directory.Exists(virtualizationRootToCleanup))
        {
            logger.LogInformation("Cleaning up virtualization root: {Root}", virtualizationRootToCleanup);
            try
            {
                Directory.Delete(virtualizationRootToCleanup, recursive: true);
                logger.LogInformation("Virtualization root deleted.");
            }
            catch (Exception ex)
            {
                logger.LogWarning(ex, "Failed to delete virtualization root. You may need to delete it manually.");
            }
        }
    }
}

async Task<IGitClient> CreateGitClientAsync(GitFsOptions options)
{
    return options.Provider switch
    {
        GitProvider.AzureDevOps => await CreateAdoClientAsync(options),
        GitProvider.GitHub => await CreateGitHubClientAsync(options),
        _ => throw new NotSupportedException($"Unsupported provider: {options.Provider}")
    };
}

async Task<IGitClient> CreateAdoClientAsync(GitFsOptions options)
{
    if (options.UseSso)
    {
        logger.LogInformation("Authenticating with Azure AD...");
        var client = await AzureDevOpsGitClient.WithSsoAsync(
            options.OrganizationUrl,
            options.Project,
            options.Repository,
            loggerFactory.CreateLogger<AzureDevOpsGitClient>());
        logger.LogInformation("Successfully authenticated via SSO.");
        return client;
    }
    else
    {
        return AzureDevOpsGitClient.WithPat(
            options.OrganizationUrl,
            options.Project,
            options.Repository,
            options.PersonalAccessToken!,
            loggerFactory.CreateLogger<AzureDevOpsGitClient>());
    }
}

async Task<IGitClient> CreateGitHubClientAsync(GitFsOptions options)
{
    if (options.UseSso)
    {
        logger.LogInformation("Authenticating with GitHub (device flow)...");
        var client = await GitHubGitClient.WithDeviceFlowAsync(
            options.Owner,
            options.Repository,
            loggerFactory.CreateLogger<GitHubGitClient>());
        logger.LogInformation("Successfully authenticated via GitHub device flow.");
        return client;
    }
    else
    {
        return GitHubGitClient.WithPat(
            options.Owner,
            options.Repository,
            options.PersonalAccessToken!,
            loggerFactory.CreateLogger<GitHubGitClient>());
    }
}

void LogRepositoryInfo(GitFsOptions options)
{
    if (options.Provider == GitProvider.AzureDevOps)
    {
        logger.LogInformation("Repository: {Org}/{Project}/_git/{Repo}", options.OrganizationUrl, options.Project, options.Repository);
    }
    else
    {
        logger.LogInformation("Repository: github.com/{Owner}/{Repo}", options.Owner, options.Repository);
    }

    if (!string.IsNullOrEmpty(options.RemotePath))
    {
        logger.LogInformation("Remote path: /{Path}", options.RemotePath);
    }
}
